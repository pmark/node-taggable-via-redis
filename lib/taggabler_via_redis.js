// Generated by CoffeeScript 1.6.3
(function() {
  var DEFAULT, EMPTY_ARRAY, EMPTY_STRING, Taggable, assert, debuglog, redis;

  redis = require("redis");

  debuglog = require("debug")("Taggable");

  assert = require("assert");

  EMPTY_STRING = '';

  EMPTY_ARRAY = [];

  DEFAULT = {
    prefix: "_T"
  };

  Taggable = (function() {
    /*
    constructor
    @param {String} taggable
    @param {uint}  [redisPort] specify custom redis port
    @param {String} [redisHost] specify custom redis host
    */

    function Taggable(options) {
      assert(options, "missing options");
      assert(options.taggable, "missing taggable in options");
      if (options.redisClient) {
        this.redisClient = options.redisClient;
      } else {
        this.redisClient = redis.createClient(options.redisPort, options.redisHost);
      }
      this.taggable = options.taggable;
      this.prefix = options.prefix || DEFAULT.prefix;
      return;
    }

    Taggable.prototype.scopedSet = function(scope, id, tags, callback) {
      var newList,
        _this = this;
      debuglog("[scopedSet] scope:" + scope + ", id:" + id + ", tags:" + tags);
      newList = tags;
      this.redisClient.smembers("" + this.prefix + ":" + scope + ":" + this.taggable + ":" + id + ":tags", function(err, oldList) {
        var added, removed, toAddCount, toRemoveCount;
        if (err != null) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        oldList = oldList || [];
        added = newList.filter(function(i) {
          return oldList.indexOf(i) === -1;
        });
        removed = oldList.filter(function(i) {
          return newList.indexOf(i) === -1;
        });
        toAddCount = added.length;
        toRemoveCount = removed.length;
        if (toAddCount === 0 && toRemoveCount === 0) {
          return typeof callback === "function" ? callback() : void 0;
        }
        added.forEach(function(tag) {
          _this.redisClient.multi().sadd("" + _this.prefix + ":" + scope + ":" + _this.taggable + ":" + id + ":tags", tag).sadd("" + _this.prefix + ":" + scope + ":" + _this.taggable + ":tags:" + tag, id).zincrby("" + _this.prefix + ":" + scope + ":" + _this.taggable + ":tags", 1, tag).sadd("" + _this.prefix + ":" + _this.taggable + ":" + id + ":tags", tag).sadd("" + _this.prefix + ":" + _this.taggable + ":tags:" + tag, id).zincrby("" + _this.prefix + ":" + _this.taggable + ":tags", 1, tag).exec(function(err, replies) {
            if (err != null) {
              return typeof callback === "function" ? callback(err) : void 0;
            }
            toAddCount--;
            if (toAddCount <= 0 && toRemoveCount <= 0) {
              return typeof callback === "function" ? callback() : void 0;
            }
          });
        });
        removed.forEach(function(tag) {
          _this.redisClient.multi().srem("" + _this.prefix + ":" + scope + ":" + _this.taggable + ":" + id + ":tags", tag).srem("" + _this.prefix + ":" + scope + ":" + _this.taggable + ":tags:" + tag, id).zincrby("" + _this.prefix + ":" + scope + ":" + _this.taggable + ":tags", -1, tag).srem("" + _this.prefix + ":" + _this.taggable + ":" + id + ":tags", tag).srem("" + _this.prefix + ":" + _this.taggable + ":tags:" + tag, id).zincrby("" + _this.prefix + ":" + _this.taggable + ":tags", -1, tag).exec(function(err, replies) {
            if (err != null) {
              return typeof callback === "function" ? callback(err) : void 0;
            }
            if (replies[2] === "0") {
              _this.redisClient.zrem("" + _this.prefix + ":" + scope + ":" + _this.taggable + ":tags", tag);
            }
            if (replies[5] === "0") {
              _this.redisClient.zrem("" + _this.prefix + ":" + _this.taggable + ":tags", tag);
            }
            toRemoveCount--;
            if (toAddCount <= 0 && toRemoveCount <= 0) {
              if (typeof callback === "function") {
                callback();
              }
            }
          });
        });
      });
    };

    Taggable.prototype.unscopedSet = function(id, tags, callback) {
      var newList,
        _this = this;
      debuglog("[unscopedSet] id:" + id + ", tags:" + tags);
      newList = tags;
      this.redisClient.smembers("" + this.prefix + ":" + this.taggable + ":" + id + ":tags", function(err, oldList) {
        var added, removed, toAddCount, toRemoveCount;
        oldList = oldList || [];
        removed = oldList.filter(function(i) {
          return newList.indexOf(i) === -1;
        });
        added = newList.filter(function(i) {
          return oldList.indexOf(i) === -1;
        });
        toAddCount = added.length;
        toRemoveCount = removed.length;
        if (toAddCount === 0 && toRemoveCount === 0) {
          return typeof callback === "function" ? callback() : void 0;
        }
        added.forEach(function(tag) {
          _this.redisClient.multi().sadd("" + _this.prefix + ":" + _this.taggable + ":" + id + ":tags", tag).sadd("" + _this.prefix + ":" + _this.taggable + ":tags:" + tag, id).zincrby("" + _this.prefix + ":" + _this.taggable + ":tags", 1, tag).exec(function(err, replies) {
            if (err != null) {
              return typeof callback === "function" ? callback(err) : void 0;
            }
            toAddCount--;
            if (toAddCount === 0 && toRemoveCount === 0) {
              if (typeof callback === "function") {
                callback();
              }
            }
          });
        });
        removed.forEach(function(tag) {
          _this.redisClient.multi().srem("" + _this.prefix + ":" + _this.taggable + ":" + id + ":tags", tag).srem("" + _this.prefix + ":" + _this.taggable + ":tags:" + tag, id).zincrby("" + _this.prefix + ":" + _this.taggable + ":tags", -1, tag).exec(function(err, replies) {
            if (replies[2] === "0") {
              _this.redisClient.zrem("" + _this.prefix + ":" + _this.taggable + ":tags", tag);
            }
            toRemoveCount--;
            if (toAddCount === 0 && toRemoveCount === 0) {
              if (typeof callback === "function") {
                callback();
              }
            }
          });
        });
      });
    };

    Taggable.prototype.set = function(scope, id, tags, callback) {
      debuglog("[set] scope:" + scope + ", id:" + id);
      if (callback) {
        this.scopedSet(scope, id, tags || EMPTY_ARRAY, callback);
      } else {
        this.unscopedSet(scope, id || EMPTY_ARRAY, tags);
      }
    };

    Taggable.prototype.get = function(scope, ids, callback) {
      var id, proc, _i, _len;
      if (typeof callback !== "function") {
        callback = ids;
        ids = scope;
        scope = "";
      } else {
        scope = ":" + scope;
      }
      debuglog("[get] scope:" + scope + ", ids:" + ids);
      if (!ids) {
        return typeof callback === "function" ? callback(null, []) : void 0;
      }
      if (!Array.isArray(ids)) {
        this.redisClient.smembers("" + this.prefix + scope + ":" + this.taggable + ":" + ids + ":tags", callback);
      } else {
        proc = this.redisClient.multi();
        for (_i = 0, _len = ids.length; _i < _len; _i++) {
          id = ids[_i];
          proc = proc.smembers("" + this.prefix + scope + ":" + this.taggable + ":" + id + ":tags");
        }
        proc.exec(callback);
      }
    };

    Taggable.prototype.find = function(scope, tags, callback) {
      var i, sets, tag, _i, _len;
      if (callback == null) {
        callback = tags;
        tags = scope;
        scope = "";
      } else {
        scope = "" + scope + ":";
      }
      debuglog("[find] scope:" + scope + ", tags:" + tags);
      if (!(tags || EMPTY_STRING).toString()) {
        return callback(null, []);
      }
      sets = [];
      if (Array.isArray(tags)) {
        for (i = _i = 0, _len = tags.length; _i < _len; i = ++_i) {
          tag = tags[i];
          sets.push("" + this.prefix + ":" + scope + this.taggable + ":tags:" + tag);
        }
      } else {
        sets.push("" + this.prefix + ":" + scope + this.taggable + ":tags:" + tags);
      }
      this.redisClient.sinter(sets, callback);
    };

    Taggable.prototype.popular = function(scope, count, callback) {
      var key;
      if (callback) {
        key = "" + this.prefix + ":" + scope + ":" + this.taggable + ":tags";
      } else {
        callback = count;
        count = scope;
        key = "" + this.prefix + ":" + this.taggable + ":tags";
      }
      this.redisClient.zrevrange(key, 0, count - 1, "WITHSCORES", function(err, reply) {
        var counter, list, tag, type;
        if (err != null) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        list = [];
        type = "key";
        tag = [];
        counter = reply.length / 2;
        reply.forEach(function(item) {
          if (type === "key") {
            type = "value";
            tag[0] = item;
          } else {
            type = "key";
            tag[1] = parseInt(item);
            list.push(tag);
            tag = [];
            counter--;
          }
          if (counter <= 0) {
            if (typeof callback === "function") {
              callback(null, list);
            }
          }
        });
      });
    };

    Taggable.quit = function() {
      return this.redisClient.quit();
    };

    return Taggable;

  })();

  module.exports = Taggable;

}).call(this);
